/*
   Copyright 2011 David Malcolm <dmalcolm@redhat.com>
   Copyright 2011 Red Hat, Inc.

   This is free software: you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see
   <http://www.gnu.org/licenses/>.
*/

#include <Python.h>
#include "gcc-python.h"
#include "gcc-python-wrappers.h"

/*
  Wrapper for GCC's opts.h

  opts.h declares:
    extern const struct cl_option cl_options[];
    extern const unsigned int cl_options_count;
  which suggests that this table is fixed in place and thus not resizable.
  (The definition is in the autogenerated DIR/gcc/options.c)

  We specifically wrap:
    enum opt_code
  and use this to get at the associated "struct cl_option" within the
  "cl_options" table.
*/

int
gcc_Option_init(PyGccOption * self, PyObject *args, PyObject *kwargs)
{
    const char *text;
    static char *kwlist[] = {"text", NULL};
    int i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s", kwlist,
                                      &text)) {
        return -1;
    }

    /* Search for text within cl_options */
    for (i = 0; i < cl_options_count; i++) {
        if (0 == strcmp(cl_options[i].opt_text, text)) {
            self->opt_code = i;
            return 0; /* success */
        }
    }

    /* Not found: */
    PyErr_Format(PyExc_ValueError,
                 "Could not find command line argument with text '%s'",
                 text);
    return -1;
}

PyObject *
gcc_Option_repr(PyGccOption * self)
{
    return gcc_python_string_from_format("gcc.Option('%s')",
                                         gcc_python_option_to_cl_option(self)->opt_text);
}

const struct cl_option*
gcc_python_option_to_cl_option(PyGccOption * self)
{
    assert(self);
    assert(self->opt_code >= 0);
    assert(self->opt_code < cl_options_count);

    return &cl_options[self->opt_code];
}

PyObject *
gcc_python_make_wrapper_opt_code(enum opt_code opt_code)
{
    struct PyGccOption *opt_obj = NULL;

    opt_obj = PyObject_New(struct PyGccOption, &gcc_OptionType);
    if (!opt_obj) {
        goto error;
    }

    opt_obj->opt_code = opt_code;

    return (PyObject*)opt_obj;

error:
    return NULL;
}

/*
  PEP-7
Local variables:
c-basic-offset: 4
indent-tabs-mode: nil
End:
*/
