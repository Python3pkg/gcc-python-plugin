#include <Python.h>
#include "gcc-python.h"
#include "gcc-python-wrappers.h"
#include "gimple.h"

//#include "rtl.h"
/*
  "struct rtx_def" is declarted within rtl.h, c.f:
    struct GTY((chain_next ("RTX_NEXT (&%h)"),
	    chain_prev ("RTX_PREV (&%h)"), variable_size)) rtx_def {
           ... snip ...
    }
    
  and seems to be the fundamental instruction type
    
  Seems to use RTX_NEXT() and RTX_PREV()
*/

/*
    Code for various tree types
 */

/* FIXME:
   This doesn't seem to be declared in any of the plugin headers:
 */
int
dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,
		   bool is_stmt);

PyObject *
gcc_Tree_str(struct PyGccTree * self)
{
    PyObject *ppobj = gcc_python_pretty_printer_new();
    PyObject *result = NULL;
    if (!ppobj) {
	return NULL;
    }

    dump_generic_node (gcc_python_pretty_printer_as_pp(ppobj),
		       self->t, 0, 0, 0);
    result = gcc_python_pretty_printer_as_string(ppobj);
    if (!result) {
	goto error;
    }
    
    Py_XDECREF(ppobj);
    return result;
    
 error:
    Py_XDECREF(ppobj);
    return NULL;
}

PyObject *
gcc_Tree_richcompare(PyObject *o1, PyObject *o2, int op)
{
    struct PyGccTree *treeobj1;
    struct PyGccTree *treeobj2;
    int cond;
    PyObject *result_obj;

    if (!PyObject_TypeCheck(o1, &gcc_TreeType)) {
	result_obj = Py_NotImplemented;
	goto out;
    }
    if (!PyObject_TypeCheck(o2, &gcc_TreeType)) {
	result_obj = Py_NotImplemented;
	goto out;
    }

    treeobj1 = (struct PyGccTree *)o1;
    treeobj2 = (struct PyGccTree *)o2;

    switch (op) {
    case Py_EQ:
	cond = (treeobj1->t == treeobj2->t);
	break;

    case Py_NE:
	cond = (treeobj1->t != treeobj2->t);
	break;

    default:
        result_obj = Py_NotImplemented;
        goto out;
    }
    result_obj = cond ? Py_True : Py_False;

 out:
    Py_INCREF(result_obj);
    return result_obj;
}

PyObject *
gcc_Declaration_repr(struct PyGccTree * self)
{
    PyObject *name = NULL;
    PyObject *result = NULL;

    if (DECL_NAME(self->t)) {
	name = gcc_Declaration_get_name(self, NULL);
	if (!name) {
	    goto error;
	}

	result = PyString_FromFormat("gcc.Declaration('%s')",
				     PyString_AsString(name));
	Py_DECREF(name);
    } else {
	result = PyString_FromFormat("gcc.Declaration(%u)",
				     DECL_UID (self->t));
    }

    return result;
error:
    Py_XDECREF(name);
    Py_XDECREF(result);
    return NULL;
}

/* 
   GCC's debug_tree is implemented in:
     gcc/print-tree.c
   e.g. in:
     /usr/src/debug/gcc-4.6.0-20110321/gcc/print-tree.c
   and appears to be a good place to look when figuring out how the tree data
   works.

   dump_generic_node is defined around line 580 of tree-pretty-print.c

   FIXME: do we want a unique PyGccTree per tree address? (e.g. by maintaining a dict?)
   (what about lifetimes?)
*/
PyObject *
gcc_python_make_wrapper_tree(tree t)
{
    struct PyGccTree *tree_obj = NULL;
    PyTypeObject* tp;

    if (NULL == t) {
	Py_RETURN_NONE;
    }
  
    tp = gcc_python_autogenerated_tree_type_for_tree(t, 1);
    assert(tp);
    
    tree_obj = PyObject_New(struct PyGccTree, tp);
    if (!tree_obj) {
        goto error;
    }

    tree_obj->t = t;
    /* FIXME: do we need to do something for the GCC GC? */

    return (PyObject*)tree_obj;
      
error:
    return NULL;
}

/*
  PEP-7  
Local variables:
c-basic-offset: 4
End:
*/
