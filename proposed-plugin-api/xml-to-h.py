import glob
import sys
from xmltypes import ApiRegistry, Api

COPYRIGHT_HEADER = '''
   Copyright 2012 David Malcolm <dmalcolm@redhat.com>
   Copyright 2012 Red Hat, Inc.

   This is free software: you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see
   <http://www.gnu.org/licenses/>.
'''

def write_header(out):
    out.write('/* This file is autogenerated: do not edit */\n')
    out.write('/*%s*/\n' % COPYRIGHT_HEADER)
    out.write('\n')

def write_footer(out):
    out.write('''
/*
  PEP-7
Local variables:
c-basic-offset: 4
indent-tabs-mode: nil
End:
*/
''')

def write_doc_comment(doc, out):
    out.write('/*\n')
    for line in doc.as_text().splitlines():
        out.write('  %s\n' % line)
    out.write('*/\n')

def write_api(api, out):
    write_header(out)

    if api.get_xml_name() == 'rtl':
        out.write('''
/* FIXME: rationalize these headers */
#include <Python.h>
#include "proposed-plugin-api/gcc-common.h"
#include "gcc-python.h"
#include "gcc-python-wrappers.h"
#include "gcc-python-compat.h"
#include "rtl.h"
#include "tree-flow.h"
''')
    else:
        out.write('#include "proposed-plugin-api/gcc-common.h"\n')

    doc = api.get_doc()
    if doc:
        write_doc_comment(doc, out)

    for type_ in api.iter_types():
        out.write('\n')
        out.write('/* %s */\n' % type_.get_c_name())

        doc = type_.get_doc()
        if doc:
            write_doc_comment(doc, out)

        # mark_in_use:
        out.write('GCC_PUBLIC_API(void)\n'
                  '%s_mark_in_use(%s %s);\n'
                  % (type_.get_c_prefix(),
                     type_.get_c_name(),
                     type_.get_varname()))

        out.write('\n')

        # add getters for attributes:
        for attr in type_.iter_attrs():
            doc = attr.get_doc()
            if doc:
                write_doc_comment(doc, out)
            if attr.get_c_name().startswith('is_'):
                # "gcc_foo_is_some_boolean", rather than
                # "gcc_foo_get_is_some_boolean":
                out.write('GCC_PUBLIC_API(%s)\n'
                          '%s_%s(%s %s);\n'
                          % (attr.get_c_type(),
                             type_.get_c_prefix(),
                             attr.get_c_name(),
                             type_.get_c_name(),
                             type_.get_varname()))
            else:
                out.write('GCC_PUBLIC_API(%s)\n'
                          '%s_get_%s(%s %s);\n'
                          % (attr.get_c_type(),
                             type_.get_c_prefix(),
                             attr.get_c_name(),
                             type_.get_c_name(),
                             type_.get_varname()))
            out.write('\n')

        # add iterators
        for iter_ in type_.iter_iters():
            itertype = iter_.get_type()
            out.write('/*\n')
            out.write('  Iterator; terminates if the callback returns truth\n')
            out.write('  (for linear search).\n')
            out.write('*/\n')
            out.write('GCC_PUBLIC_API(bool)\n'
                      '%s_for_each_%s(%s %s,\n'
                      '    bool (*cb)(%s %s, void *user_data),\n'
                      '    void *user_data);\n'
                      % (type_.get_c_prefix(),
                         iter_.get_c_name(),
                         type_.get_c_name(),
                         type_.get_varname(),
                         itertype.get_c_name(),
                         itertype.get_varname()))
            out.write('\n')

        # add upcast
        if type_.get_base():
            out.write('GCC_PUBLIC_API(%s)\n'
                      '%s_upcast(%s %s);\n'
                      % (type_.get_base().get_c_name(),
                         type_.get_c_prefix(),
                         type_.get_c_name(),
                         type_.get_varname()))

        # add downcasts
        for subclass in type_.get_subclasses():
            out.write('GCC_PUBLIC_API(%s)\n'
                      '%s_as_%s(%s %s);\n\n'
                      % (subclass.get_c_name(),
                         type_.get_c_prefix(),
                         subclass.get_c_name(),
                         type_.get_c_name(),
                         type_.get_varname()))


    # add getters for attributes:
    for attr in api.iter_attrs():
        doc = attr.get_doc()
        if doc:
            write_doc_comment(doc, out)
        if attr.is_readable():
            out.write('GCC_PUBLIC_API(%s)\n'
                      'gcc_get_%s(void);\n'
                      % (attr.get_c_type(),
                         attr.get_c_name()))
        if attr.is_writable():
            out.write('GCC_PUBLIC_API(void)\n'
                      'gcc_set_%s(%s %s);\n'
                      % (attr.get_c_name(),
                         attr.get_c_type(),
                         attr.get_varname()))
        out.write('\n')

    write_footer(out)

def write_public_types(registry, out):
    write_header(out)
    out.write('#ifndef INCLUDED__GCC_PUBLIC_TYPES_H\n')
    out.write('#define INCLUDED__GCC_PUBLIC_TYPES_H\n')
    out.write('\n')
    out.write('#include "gcc-semiprivate-types.h"\n')
    out.write('\n')
    for api in registry.apis:
        out.write('/* Opaque types: %s */\n' % api.get_doc().as_text())
        for type_ in api.iter_types():
            out.write('typedef struct %s %s;\n'
                      % (type_.get_c_name(), type_.get_c_name()))
        out.write('\n')

    out.write('#endif /* INCLUDED__GCC_PUBLIC_TYPES_H */')
    write_footer(out)

def write_semiprivate_types(registry, out):
    write_header(out)
    out.write('#ifndef INCLUDED__GCC_SEMIPRIVATE_TYPES_H\n')
    out.write('#define INCLUDED__GCC_SEMIPRIVATE_TYPES_H\n')

    out.write('\n')
    out.write('#include "input.h" /* for location_t */\n')
    out.write('\n')
    out.write('/*\n')
    out.write('  These "interface types" should be treated like pointers, only that\n')
    out.write('  users are required to collaborate with the garbage-collector.\n')
    out.write('\n')
    out.write('  The internal details are exposed here so that the debugger is able to\n')
    out.write('  identify the real types.  Plugin developers should *not* rely on the\n')
    out.write('  internal implementation details.\n')
    out.write('\n')
    out.write('  By being structs, the compiler will be able to complain if plugin code\n')
    out.write('  directly pokes at a pointer.\n')
    out.write('*/\n')

    for api in registry.apis:
        out.write('/* Semiprivate types: %s */\n' % api.get_doc().as_text())
        for type_ in api.iter_types():
            out.write('struct %s {\n' % type_.get_c_name())
            out.write('  %s inner;\n' % type_.get_inner_type())
            out.write('};\n')
            out.write('\n')
            out.write('GCC_PRIVATE_API(struct %s)\n' % type_.get_c_name())
            out.write('gcc_private_make_%s(%s inner);\n'
                      % (type_.get_xml_name(),
                         type_.get_inner_type()))
            out.write('\n')

    out.write('#endif /* INCLUDED__GCC_SEMIPRIVATE_TYPES_H */')
    write_footer(out)

registry = ApiRegistry()
for xmlfile in sorted(glob.glob('*.xml')):
    api = Api(registry, xmlfile)
for api in registry.apis:
    with open('gcc-%s.h' % api.get_xml_name(), 'w') as f:
        # write(api, sys.stdout)
        write_api(api, f)
    with open('gcc-public-types.h', 'w') as f:
        write_public_types(registry, f)
    with open('gcc-semiprivate-types.h', 'w') as f:
        write_semiprivate_types(registry, f)
