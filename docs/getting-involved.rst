.. Copyright 2012 David Malcolm <dmalcolm@redhat.com>
   Copyright 2012 Red Hat, Inc.

   This is free software: you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see
   <http://www.gnu.org/licenses/>.

Getting Involved
================

The plugin's web site is the Trac instance at: https://fedorahosted.org/gcc-python-plugin/

The primary place for discussion of the plugin is the mailing list:
https://fedorahosted.org/mailman/listinfo/gcc-python-plugin

A pre-built version of the HTML documentation can be seen at:

http://readthedocs.org/docs/gcc-python-plugin/en/latest/index.html

The project's mailing list is here: https://fedorahosted.org/mailman/listinfo/gcc-python-plugin

There's also a mailing list that receives commit notifications here: https://fedorahosted.org/mailman/listinfo/gcc-python-plugin-commits

Bugs can be filed with the Trac instance:

  https://fedorahosted.org/gcc-python-plugin/newticket

though you need a Fedora account to do so (creating a Fedora account is trivial; see: http://fedoraproject.org/wiki/Account_System/NewAccount )

The code is stored in the git repository here:

   http://git.fedorahosted.org/git/?p=gcc-python-plugin.git;a=summary

You can obtain the source code from git by using::

   $ git clone git://git.fedorahosted.org/gcc-python-plugin.git

There is also a clone of the repository on github here:

   https://github.com/davidmalcolm/gcc-python-plugin


Tour of the C code
------------------
The plugin's C code heavily uses Python's extension API, and so it's worth
knowing this API if you're going to hack on this part of the project.  A good
tutorial for this can be seen here:

  http://docs.python.org/extending/index.html

and detailed notes on it are here:

  http://docs.python.org/c-api/index.html

Most of the C "glue" for creating classes and registering their methods and
attributes is autogenerated.  Simple C one-liners tend to appear in the
autogenerated C files, whereas longer implementations are broken out into
a hand-written C file.

Adding new methods and attributes to the classes requires editing the
appropriate generate-\*.py script to wire up the new entrypoint.  For
very simple attributes you can embed the C code directly there, but
anything that's more than a one-liner should have its implementation in
the relevant C file.

For example, to add new methods to a :py:class:`gcc.Cfg` you'd edit:

  * `generate-cfg-c.py` to add the new methods and attributes to the relevant
    tables of callbacks

  * `gcc-python-wrappers.h` to add declarations of the new C functions

  * `gcc-python-cfg.c` to add the implementations of the new C functions

Please try to make the API "Pythonic".

My preference with getters is that if the implementation is a simple
field lookup, it should be an attribute (the "getter" is only implicit,
existing at the C level)::

   print(bb.loopcount)

whereas if getting the result involves some work, it should be an
explicit method of the class (where the "getter" is explicit at the
Python level)::

   print(bb.get_loop_count())


Using the plugin to check itself
--------------------------------
Given that the `cpychecker` code implements new error-checking for Python C
code, and that the underlying plugin is itself an example of such code, it's
possible to build the plugin once, then compile it with itself (using
CC=gcc-with-cpychecker as a Makefile variable::

  $ make CC=/path/to/a/clean/build/of/the/plugin/gcc-with-cpychecker

Unfortunately it doesn't quite compile itself cleanly right
now.

.. TODO: add notes on the current known problems


Test suite
----------
There are three test suites:

  * `testcpybuilder.py`: a minimal test suite which is used before the plugin
    itself is built.  This verifies that the `cpybuilder` code works.

  * `make test-suite` (aka `run-test-suite.py`): a test harness and suite
    which was written for this project.  See the notes below on patches.

  * `make testcpychecker` and `testcpychecker.py`: a suite based on Python's
    `unittest` module


Debugging the plugin's C code
-----------------------------

The `gcc` binary is a harness that launches subprocesses, so it can be fiddly
to debug.

When debugging, I've generally been adding "-v" to the gcc command line
(verbose), so that it outputs the commands that it's running.  I can then use
this to launch::

   $ gdb --args ACTUAL PROGRAM WITH ACTUAL ARGS

to debug the subprocess that actually loads the Python plugin.

For example::

  $ gcc -v -fplugin=$(pwd)/python.so -fplugin-arg-python-script=test.py test.c

on my machine emits this::

   Using built-in specs.
   COLLECT_GCC=gcc
   COLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/4.6.1/lto-wrapper
   Target: x86_64-redhat-linux
   Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --enable-languages=c,c++,objc,obj-c++,java,fortran,ada,go,lto --enable-plugin --enable-java-awt=gtk --disable-dssi --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-1.5.0.0/jre --enable-libgcj-multifile --enable-java-maintainer-mode --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --disable-libjava-multilib --with-ppl --with-cloog --with-tune=generic --with-arch_32=i686 --build=x86_64-redhat-linux
   Thread model: posix
   gcc version 4.6.1 20110908 (Red Hat 4.6.1-9) (GCC) 
   COLLECT_GCC_OPTIONS='-v' '-fplugin=/home/david/coding/gcc-python/gcc-python/contributing/python.so' '-fplugin-arg-python-script=test.py' '-mtune=generic' '-march=x86-64'
    /usr/libexec/gcc/x86_64-redhat-linux/4.6.1/cc1 -quiet -v -iplugindir=/usr/lib/gcc/x86_64-redhat-linux/4.6.1/plugin test.c -iplugindir=/usr/lib/gcc/x86_64-redhat-linux/4.6.1/plugin -quiet -dumpbase test.c -mtune=generic -march=x86-64 -auxbase test -version -fplugin=/home/david/coding/gcc-python/gcc-python/contributing/python.so -fplugin-arg-python-script=test.py -o /tmp/cc1Z3b95.s
   (output of the script follows)

This allows us to see the line in which `cc1` is invoked: in the above
example, it's the final line before the output from the script::

  /usr/libexec/gcc/x86_64-redhat-linux/4.6.1/cc1 -quiet -v -iplugindir=/usr/lib/gcc/x86_64-redhat-linux/4.6.1/plugin test.c -iplugindir=/usr/lib/gcc/x86_64-redhat-linux/4.6.1/plugin -quiet -dumpbase test.c -mtune=generic -march=x86-64 -auxbase test -version -fplugin=/home/david/coding/gcc-python/gcc-python/contributing/python.so -fplugin-arg-python-script=test.py -o /tmp/cc1Z3b95.s

We can then take this line and rerun this subprocess under gdb by adding
`gdb --args` to the front like this::

   $ gdb --args /usr/libexec/gcc/x86_64-redhat-linux/4.6.1/cc1 -quiet -v -iplugindir=/usr/lib/gcc/x86_64-redhat-linux/4.6.1/plugin test.c -iplugindir=/usr/lib/gcc/x86_64-redhat-linux/4.6.1/plugin -quiet -dumpbase test.c -mtune=generic -march=x86-64 -auxbase test -version -fplugin=/home/david/coding/gcc-python/gcc-python/contributing/python.so -fplugin-arg-python-script=test.py -o /tmp/cc1Z3b95.s

This approach to obtaining a debuggable process doesn't seem to work in the
presence of `ccache`, in that it writes to a temporary directory with a name
that embeds the process ID each time, which then gets deleted.  I've worked
around this by uninstalling ccache, but apparently setting::

   CCACHE_DISABLE=1

before invoking `gcc -v` ought to also work around this.

I've also been running into this error from gdb::

  [Thread debugging using libthread_db enabled]
  Cannot find new threads: generic error

Apparently this happens when debugging a process that uses dlopen to load a
library that pulls in libpthread (as does gcc when loading in my plugin), and
a workaround is to link cc1 with -lpthread

The workaround I've been using (to avoid the need to build my own gcc) is to
use LD_PRELOAD, either like this::

   LD_PRELOAD=libpthread.so.0 gdb --args ARGS GO HERE...

or this::

   (gdb) set environment LD_PRELOAD libpthread.so.0


Handy tricks
++++++++++++

Given a (PyGccTree*) named "self"::

   (gdb) call debug_tree(self->t)

will use GCC's prettyprinter to dump the embedded (tree*) and its descendants
to stderr; it can help to put a breakpoint on that function too, to explore the
insides of that type.

Patches
-------
The project doesn't have any copyright assignment requirement: you get
to keep copyright in any contributions you make, though AIUI there's an
implicit licensing of such contributions under the GPLv3 or later, given
that any contribution is a derived work of the plugin, which is itself
licensed under the GPLv3 or later.   I'm not a lawyer, though.

The Python code within the project is intended to be usable with both Python 2
and Python 3 without running 2to3: please stick to the common subset of the two
languages.  For example, please write print statements using parentheses::

   print(42)

Under Python 2 this is a `print` statement with a parenthesized number: (42)
whereas under Python 3 this is an invocation of the `print` function.

Please try to stick `PEP-8 <http://www.python.org/dev/peps/pep-0008/>`_ for
Python code, and to `PEP-7 <http://www.python.org/dev/peps/pep-0007/>`_ for
C code (rather than the GNU coding conventions).

In C code, I strongly prefer to use multiline blocks throughout, even where
single statements are allowed (e.g. in an "if" statement)::

   if (foo()) {
       bar();
   }

as opposed to::

   if (foo())
       bar();

since this practice prevents introducing bugs when modifying such code, and the
resulting "diff" is much cleaner.

A good patch ought to add test cases for the new code that you write, and
documentation.

The test cases should be grouped in appropriate subdirectories of "tests". 
Each new test case is a directory with an:

  * `input.c` (or `input.cc` for C++)

  * `script.py` exercising the relevant Python code

  * `stdout.txt` containing the expected output from the script.

For more realistic examples of test code, put them below `tests/examples`;
these can be included by reference from the docs, so that we have
documentation that's automatically verified by `run-test-suite.py`, and
users can use this to see the relationship between source-code constructs
and the corresponding Python objects.

More information can be seen in `run-test-suite.py`

You can generate the "gold" stdout.txt by hacking up this line in
run-test-suite.py::

   out.check_for_diff(out.actual, err.actual, p, args, 'stdout', 0)

so that the final 0 is a 1 (the "writeback" argument to `check_for_diff`).
There may need to be a non-empty stdout.txt file in the directory for
this to take effect though.

Unfortunately, this approach over-specifies the selftests, making them
rather "brittle".  Improvements to this approach would be welcome.


Documentation
=============
We use Sphinx for documentation, which makes it easy
to keep the documentation up-to-date.   For notes on how to document
Python in the .rst form accepted by Sphinx, see e.g.:

   http://sphinx.pocoo.org/domains.html#the-python-domain
